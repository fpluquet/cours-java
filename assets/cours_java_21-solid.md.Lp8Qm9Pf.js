import{_ as s,c as i,o as n,a2 as a}from"./chunks/framework.DYZYzxF5.js";const h=JSON.parse('{"title":"Les principes SOLID","description":"","frontmatter":{},"headers":[],"relativePath":"cours/java/21-solid.md","filePath":"cours/java/21-solid.md"}'),t={name:"cours/java/21-solid.md"};function r(l,e,o,p,u,c){return n(),i("div",null,e[0]||(e[0]=[a(`<h1 id="les-principes-solid" tabindex="-1">Les principes SOLID <a class="header-anchor" href="#les-principes-solid" aria-label="Permalink to &quot;Les principes SOLID&quot;">​</a></h1><p>Les principes <strong>SOLID</strong> sont cinq règles fondamentales de la programmation orientée objet. Ils servent de guide pour concevoir des logiciels robustes, évolutifs et faciles à maintenir. Bien appliqués, ils rendent le code plus modulaire, flexible, testable et compréhensible.</p><blockquote><p><strong>Info :</strong> Les principes SOLID ne sont pas réservés aux « experts » : ils s’appliquent à tous les niveaux, même dans de petits projets. Les comprendre, c’est progresser vers une programmation professionnelle.</p></blockquote><hr><h2 id="s-—-single-responsibility-principle-responsabilite-unique" tabindex="-1">S — Single Responsibility Principle (Responsabilité unique) <a class="header-anchor" href="#s-—-single-responsibility-principle-responsabilite-unique" aria-label="Permalink to &quot;S — Single Responsibility Principle (Responsabilité unique)&quot;">​</a></h2><p><strong>Définition :</strong> Chaque classe ou module doit avoir une seule responsabilité, c’est-à-dire une seule raison de changer.</p><p><strong>Explication :</strong> Une classe qui fait trop de choses devient difficile à maintenir. Si une modification concerne plusieurs aspects, on risque d’introduire des bugs ailleurs.</p><blockquote><p><strong>Exemple pédagogique :</strong></p><ul><li>Une classe <code>Facture</code> qui gère à la fois le calcul du montant et l’impression du PDF viole ce principe. Il vaut mieux séparer ces responsabilités.</li></ul></blockquote><hr><h2 id="o-—-open-closed-principle-ouvert-ferme" tabindex="-1">O — Open/Closed Principle (Ouvert/Fermé) <a class="header-anchor" href="#o-—-open-closed-principle-ouvert-ferme" aria-label="Permalink to &quot;O — Open/Closed Principle (Ouvert/Fermé)&quot;">​</a></h2><p><strong>Définition :</strong> Les entités logicielles (classes, modules, fonctions) doivent être <strong>ouvertes à l’extension</strong> mais <strong>fermées à la modification</strong>.</p><p><strong>Explication :</strong> On doit pouvoir ajouter de nouveaux comportements sans modifier le code existant, par exemple en utilisant l’héritage ou les interfaces.</p><blockquote><p><strong>Info :</strong> Privilégiez l’ajout de nouvelles classes ou méthodes plutôt que la modification de celles déjà en place.</p></blockquote><hr><h2 id="l-—-liskov-substitution-principle-substitution-de-liskov" tabindex="-1">L — Liskov Substitution Principle (Substitution de Liskov) <a class="header-anchor" href="#l-—-liskov-substitution-principle-substitution-de-liskov" aria-label="Permalink to &quot;L — Liskov Substitution Principle (Substitution de Liskov)&quot;">​</a></h2><p><strong>Définition :</strong> Une classe dérivée doit pouvoir être utilisée à la place de sa classe parente sans altérer la justesse du programme.</p><p><strong>Explication :</strong> Si une sous-classe ne respecte pas le contrat de la classe parente, le code risque de mal fonctionner ou de produire des erreurs inattendues.</p><p><strong>Exemple :</strong></p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Oiseau</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> voler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* ... */</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Canard</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Oiseau</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Autruche</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Oiseau</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Override</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> voler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        throw</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> UnsupportedOperationException</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Problème : une autruche ne vole pas !</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><blockquote><p><strong>À éviter :</strong> Ici, <code>Autruche</code> ne respecte pas le contrat de <code>Oiseau</code> : toutes les méthodes de la classe parente ne sont pas valides pour la sous-classe.</p></blockquote><hr><h2 id="i-—-interface-segregation-principle-separation-des-interfaces" tabindex="-1">I — Interface Segregation Principle (Séparation des interfaces) <a class="header-anchor" href="#i-—-interface-segregation-principle-separation-des-interfaces" aria-label="Permalink to &quot;I — Interface Segregation Principle (Séparation des interfaces)&quot;">​</a></h2><p><strong>Définition :</strong> Il vaut mieux plusieurs petites interfaces spécifiques qu’une grosse interface générale.</p><p><strong>Explication :</strong> Une classe ne devrait jamais être obligée d’implémenter des méthodes dont elle n’a pas besoin. Cela rend le code plus clair et plus facile à maintenir.</p><blockquote><p><strong>Info :</strong> Découpez vos interfaces pour qu’elles soient cohérentes et ciblées.</p></blockquote><hr><h2 id="d-—-dependency-inversion-principle-inversion-des-dependances" tabindex="-1">D — Dependency Inversion Principle (Inversion des dépendances) <a class="header-anchor" href="#d-—-dependency-inversion-principle-inversion-des-dependances" aria-label="Permalink to &quot;D — Dependency Inversion Principle (Inversion des dépendances)&quot;">​</a></h2><p><strong>Définition :</strong> Dépendre des abstractions (interfaces), pas des implémentations concrètes.</p><p><strong>Explication :</strong> Au lieu de créer directement les objets dont une classe a besoin, on les lui fournit (injection de dépendance). Cela rend le code plus flexible et testable.</p><blockquote><p><strong>Pour aller plus loin :</strong> Voir le chapitre sur les interfaces pour un exemple détaillé d’inversion de dépendance.</p></blockquote><hr><h2 id="pourquoi-appliquer-solid" tabindex="-1">Pourquoi appliquer SOLID ? <a class="header-anchor" href="#pourquoi-appliquer-solid" aria-label="Permalink to &quot;Pourquoi appliquer SOLID ?&quot;">​</a></h2><ul><li>Facilite la maintenance et l’évolution du code</li><li>Favorise la réutilisabilité et les tests unitaires</li><li>Réduit les effets de bord lors des modifications</li><li>Rend le code plus compréhensible pour les autres développeurs</li></ul><blockquote><p><strong>Résumé pédagogique :</strong> Appliquer SOLID, c’est écrire du code plus propre, plus modulaire et plus durable. Essayez d’identifier ces principes dans vos projets et de les mettre en pratique progressivement.</p></blockquote><hr><h2 id="pour-s-entrainer" tabindex="-1">Pour s’entraîner <a class="header-anchor" href="#pour-s-entrainer" aria-label="Permalink to &quot;Pour s’entraîner&quot;">​</a></h2><ul><li>Repérez dans vos projets ou exercices des exemples où un principe SOLID n’est pas respecté. Comment pourriez-vous améliorer la conception ?</li><li>Essayez de reformuler une classe « dieu » (qui fait tout) en plusieurs classes à responsabilité unique.</li><li>Proposez une interface trop générale, puis segmentez-la en interfaces plus spécifiques.</li></ul><hr><p><em>Les principes SOLID sont des repères pour progresser en conception objet. Plus vous les appliquez, plus votre code gagne en qualité et en robustesse !</em></p>`,39)]))}const k=s(t,[["render",r]]);export{h as __pageData,k as default};

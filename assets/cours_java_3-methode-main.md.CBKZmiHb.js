import{_ as i,c as a,o as e,a2 as n}from"./chunks/framework.CTq9ZtpZ.js";const k=JSON.parse('{"title":"La méthode main","description":"","frontmatter":{},"headers":[],"relativePath":"cours/java/3-methode-main.md","filePath":"cours/java/3-methode-main.md"}'),t={name:"cours/java/3-methode-main.md"};function l(p,s,h,o,r,d){return e(),a("div",null,[...s[0]||(s[0]=[n(`<h1 id="la-methode-main" tabindex="-1">La méthode <code>main</code> <a class="header-anchor" href="#la-methode-main" aria-label="Permalink to &quot;La méthode \`main\`&quot;">​</a></h1><p>Au cœur de chaque programme Java, il y a un point de départ, un rituel immuable : la méthode <code>main</code>. C’est elle qui donne vie à votre application, qui orchestre le tout premier souffle de votre code.</p><p>Comme nous l’avons déjà évoqué, Java est un langage farouchement orienté objet. Rien n’existe en dehors d’une classe, et la méthode <code>main</code> ne fait pas exception à la règle. Elle est le portail d’entrée, le chef d’orchestre qui lance l’exécution.</p><p>Sa signature est sacrée :</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[] args)</span></span></code></pre></div><ul><li><code>public</code> : pour être accessible par la machine virtuelle Java.</li><li><code>static</code> : car elle doit pouvoir être appelée sans qu’aucun objet ne soit encore créé.</li><li><code>void</code> : elle ne renvoie rien, elle agit.</li><li><code>String[] args</code> : un tableau de chaînes de caractères, pour recevoir d’éventuels arguments passés lors du lancement du programme.</li></ul><p>À noter : contrairement à d’autres langages comme C#, le nom du fichier exécuté ne fait pas partie de ces arguments. Seuls les paramètres explicitement fournis à l’exécution y figurent.</p><h2 id="exemple-exploiter-les-arguments-de-la-ligne-de-commande" tabindex="-1">Exemple : exploiter les arguments de la ligne de commande <a class="header-anchor" href="#exemple-exploiter-les-arguments-de-la-ligne-de-commande" aria-label="Permalink to &quot;Exemple : exploiter les arguments de la ligne de commande&quot;">​</a></h2><p>La méthode <code>main</code> peut recevoir des paramètres lors du lancement du programme. Ceux-ci sont accessibles via le tableau <code>args</code>. Voici un exemple simple qui affiche chaque argument reçu :</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ArgumentsDemo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[] </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Nombre d&#39;arguments : &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> args.length);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> args.length; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Argument &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot; : &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> args[i]);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Si vous lancez ce programme avec la commande :</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>java ArgumentsDemo bonjour 42 test</span></span></code></pre></div><p>Vous obtiendrez :</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Nombre d&#39;arguments : 3</span></span>
<span class="line"><span>Argument 0 : bonjour</span></span>
<span class="line"><span>Argument 1 : 42</span></span>
<span class="line"><span>Argument 2 : test</span></span></code></pre></div><p>Ainsi, la méthode <code>main</code> est la porte d’entrée universelle de vos aventures Java. C’est ici que tout commence !</p><h2 id="nouveaute-java-25-simplification-de-la-methode-main" tabindex="-1">Nouveauté Java 25 : simplification de la méthode <code>main</code> <a class="header-anchor" href="#nouveaute-java-25-simplification-de-la-methode-main" aria-label="Permalink to &quot;Nouveauté Java 25 : simplification de la méthode \`main\`&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">Java 25</p><p>Depuis Java 25, la signature de la méthode <code>main</code> a été considérablement simplifiée. Cette évolution vise à rendre le langage plus accessible aux débutants, en supprimant les éléments « cérémoniels » inutiles pour les petits programmes.</p></div><h3 id="instance-main-methods" tabindex="-1">Instance <code>main</code> methods <a class="header-anchor" href="#instance-main-methods" aria-label="Permalink to &quot;Instance \`main\` methods&quot;">​</a></h3><p>Les mots-clés <code>public</code>, <code>static</code> et le paramètre <code>String[] args</code> ne sont plus obligatoires. Java 25 permet d&#39;écrire une méthode <code>main</code> d&#39;instance, sans paramètre :</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Avant Java 25 (toujours valide)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> HelloWorld</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[] </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Hello, World!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Depuis Java 25 : signature simplifiée</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> HelloWorld</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Hello, World!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Le lanceur Java choisit la méthode <code>main</code> selon cette priorité :</p><ol><li>S&#39;il existe une méthode <code>main(String[] args)</code> (statique ou non), elle est choisie.</li><li>Sinon, s&#39;il existe une méthode <code>main()</code> sans paramètre, elle est choisie.</li><li>Si la méthode choisie n&#39;est pas <code>static</code>, Java instancie la classe (qui doit avoir un constructeur sans argument) puis appelle <code>main()</code> sur l&#39;objet créé.</li></ol><div class="info custom-block"><p class="custom-block-title">INFO</p><p>La version classique <code>public static void main(String[] args)</code> reste parfaitement valide. La nouvelle syntaxe est simplement une alternative plus concise, idéale pour les petits programmes et l&#39;apprentissage.</p></div><h3 id="compact-source-files-fichiers-sources-compacts" tabindex="-1">Compact Source Files (fichiers sources compacts) <a class="header-anchor" href="#compact-source-files-fichiers-sources-compacts" aria-label="Permalink to &quot;Compact Source Files (fichiers sources compacts)&quot;">​</a></h3><p>Java 25 va encore plus loin : il est possible d&#39;écrire un programme sans même déclarer de classe ! On écrit directement les méthodes et champs dans le fichier source. Le compilateur crée automatiquement une classe implicite.</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Fichier HelloWorld.java — pas de déclaration de classe !</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Hello, World!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>On peut même y déclarer des méthodes auxiliaires et des champs :</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Fichier Greeting.java</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">String </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">greeting</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Hello, World!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">greeting</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><div class="warning custom-block"><p class="custom-block-title">Attention</p><p>Un fichier source compact doit obligatoirement contenir une méthode <code>main</code> exécutable. La classe implicite créée par le compilateur n&#39;a pas de nom utilisable dans le code source (on ne peut pas l&#39;instancier avec <code>new</code>).</p></div><div class="info custom-block"><p class="custom-block-title">Imports automatiques</p><p>Dans un fichier source compact, toutes les classes publiques du module <code>java.base</code> sont automatiquement importées (comme si <code>import module java.base;</code> était présent en haut du fichier). Cela inclut <code>java.util.List</code>, <code>java.io.File</code>, <code>java.util.stream.Stream</code>, etc.</p></div><p>Cette approche progressive (compact → classe explicite → projet structuré) permet aux débutants de se concentrer sur la logique avant de découvrir les concepts d&#39;encapsulation et de modularité.</p>`,31)])])}const u=i(t,[["render",l]]);export{k as __pageData,u as default};
